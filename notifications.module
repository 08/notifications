<?php
// $Id: notifications.module,v 1.6.2.9.2.50.2.18.2.67 2010/07/22 11:57:49 jareyero Exp $

/**
 * @file
 * Notifications module
 *
 * This is the base module of the notifications framework. It handles event processing, queueing,
 * message composition and sending.
 * 
 * Different subscriptions types are provided by plug-in modules implementing hook_notifications()
 * Most of the UI is implemented in notifications_ui module
 * The messaging framework is used for message delivery
 * Token module is used for token replacement in messages 
 * 
 * This is based on the previous subscriptions module
 * 
 * Development Seed, http://www.developmentseed.org, 2007 
 *
 */

// Format as plaintext. Note it evaluates to false.
define('NOTIFICATIONS_FORMAT_PLAIN', 0);
// Format as html. Note it evaluates to true
define('NOTIFICATIONS_FORMAT_HTML', 1);
// Format inline, as a string of csv
define('NOTIFICATIONS_FORMAT_INLINE', 2);
// Format as HTML table (4 +1)
define('NOTIFICATIONS_FORMAT_TABLE', 5);
// Format as item list (8 + 2(inline) + 1 (html))
define('NOTIFICATIONS_FORMAT_LIST', 10);

/**
 * Implementation of hook_menu().
 */
function notifications_menu() {
  $items['admin/config/notifications'] = array(
    'title' => 'Notififications',
    'description' => 'Administer and configure notifications',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/config/notifications/settings'] = array(
    'title' => 'Notifications settings',
    'description' => 'Configure notifications.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
  );
  $items['admin/config/notifications/settings/overview'] = array(
    'title' => 'Options',
    'description' => 'Configure notifications',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/notifications/settings/intervals'] = array(
    'title' => 'Intervals',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_send_intervals_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
  );
  $items['admin/config/notifications/settings/events'] = array(
    'title' => 'Events',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_admin_events_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
  );

  $items['admin/config/notifications/subscriptions'] = array(
    'title' => 'Subscriptions settings',
    'description' => 'Configure subscription types and options.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_admin_subscriptions_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
  );
  $items['admin/config/notifications/subscriptions/types'] = array(
    'title' => 'Options',
    'description' => 'Subscription options.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  // Manage existing subscriptions
  $items['admin/people/subscriptions'] = array(
    'title' => 'Manage subscriptions',
    'description' => 'Manage existing subscriptions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_admin_manage_subscriptions'),
    'access arguments' => array('administer notifications'),
    'file' => 'notifications.admin.inc',
  ); 

  $items['admin/people/subscriptions/admin'] = array(
    'title' => 'Administer',
    'description' => 'Administer subscriptions.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer notifications'),
  );
  $items['admin/people/subscriptions/status'] = array(
    'title' => 'Status',
    'description' => 'Summary of existing subscriptions.',
    'page callback' => 'notifications_admin_status_page',
    'access arguments' => array('administer notifications'),
    'file' => 'notifications.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
return $items;
  // Subscribe links. For this items access will be checked later in the page
  $items['notifications/subscribe/%notifications_subscription_type'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'notifications_page_subscribe',
    'page arguments' => array(2),
    'access callback' => 'notifications_access_subscribe',
    'access arguments' => array(2),
    'file' => 'notifications.pages.inc',
  );
  // Unsubscribe links This page will need to work with anonymous users
  // The parameter will be a list of sids, separated by commas
  $items['notifications/unsubscribe/'] = array(
    'type' => t('Unsubscribe'),
    'page callback' => 'notifications_page_unsubscribe',
    'access callback' => TRUE,
    'file' => 'notifications.pages.inc',
  );
  // Edit subscription, stand alone page
  $items['notifications/subscription/%notifications_subscription'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Edit subscription',
    'page callback' => 'notifications_subscription_edit_page',
    'page arguments' => array(2),
    'access callback' => 'notifications_subscription_access',
    'access arguments' => array('edit', 2),
    'file' => 'notifications.pages.inc',
  );
  // Some autocomplete callbacks
  $items['notifications/autocomplete/node/title'] = array(
    'title' => 'Node title autocomplete',
    'page callback' => 'notifications_node_autocomplete_title',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/node.inc',
  );
  // Some autocomplete callbacks
  $items['notifications/autocomplete/node/type'] = array(
    'title' => 'Node title autocomplete',
    'page callback' => 'notifications_node_autocomplete_type',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/node.inc',
  );
  return $items;
}

/**
 * Menu access callback for subscribe links
 * 
 * More access checking depending on subscription type will be done at the destination page
 */
function notifications_access_subscribe($subscription, $account) {
  if ($account && $subscription) {
    if (notifications_check_signature()) {
      return TRUE; // Signed link
    }
    elseif (user_access('administer notifications') || user_access('manage all subscriptions')) {
      return TRUE;
    }
    else {
      return ($GLOBALS['user']->uid == $account->uid) && $subscription->user_access($account);
    }
  }
}

/**
 * Menu access callback for user subscriptions
 * 
 * @param $account
 *   User account to which these subscriptions below
 * @param $op
 *   - maintain = create / delete
 *   - manage = use the per account administration page
 */
function notifications_access_user($account, $op = 'maintain') {
  global $user;
  
  if (user_access('administer notifications') || user_access('manage all subscriptions')) {
    return TRUE;
  }
  else {
    return $account->uid && $user->uid == $account->uid &&
      (($op == 'maintain' && user_access('maintain own subscriptions')) || ($op == 'manage' && user_access('manage own subscriptions')));
  }
}

/**
 * Menu access callback, add a given subscription type
 */
function notifications_access_user_add($account = NULL, $type = NULL) {
  global $user;
  
  $account = $account ? $account : $user;  
  if (notifications_access_user($account)) {
    if ($type) {
      return notifications_subscription($type)->user_access($account);
    }
    else {
      return TRUE;
    }
  }
}

/**
 * Check signature from URL and query string
 */
function notifications_check_signature() {
  if (!empty($_GET['signature'])) {
    $query = $_GET;
    $signature = $query['signature'];
    unset($query['signature']);
    unset($query['q']); // Trim out the path element
    $path = current_path();
    if ($signature === notifications_url_signature($path, $query)) {
      // Now check timestamp, it should be < 7 days
      if (!empty($query['timestamp']) && time() - 24 * 7 * 3600 > (int)$query['timestamp']) {
        drupal_set_message(t('This link has expired. Please get a new one or contact the site administrator.'), 'error');
        return FALSE;
      }        
      else {
        // Signature is ok and timestamp is ok or we don't have one.
        // (If you sign links that never expire, that's your problem.)
        return TRUE;
      }
    }
    else {
      drupal_set_message(t('This link is not valid anymore. Please get a new one or contact the site administrator.'), 'error');
      return FALSE;
    }
  }
  // Return nothing, we didn't have any signature
}


/**
 * Check access for anonymous subscriptions
 */
function notifications_access_anonymous() {
  static $access;
  if (!isset($access)) {
    $access = module_exists('notifications_anonymous') && notifications_anonymous_send_methods() && notifications_anonymous_send_intervals();
  }
  return $access;
}

/**
 * Menu loading, subscription
 */
function notifications_subscription_load($sid) {
  return Notifications_Subscription_Instance::load($sid);
}

/**
 * Menu access callback
 */
function notifications_subscription_access($op, $subscription, $account = NULL) {
  global $user;

  $account = $account ? $account : $user;  
  if (user_access('administer notifications') || user_access('manage all subscriptions')) {
    return TRUE;
  } 
  switch ($op) {
    case 'edit':
    case 'unsubscribe':
      return $subscription->uid && ($subscription->uid == $account->uid) && user_access('maintain own subscriptions');
  }
  return FALSE;
}

/**
 * Menu access callback for destinations
 */
function notifications_destination_access($op, $destination) {  
  // Access will be granted only to administrator for now
  return user_access('administer notifications');
}

/**
 * Implements hook_entity_info().
 */
function notifications_entity_info() {
  // Notifications_Event
  $info['notifications_event'] = array(
    'label' => t('Event'),
    'controller class' => 'MessagingEntityController',
    'base class' => 'Notifications_Event',
    'base table' => 'notifications_event',
    'entity keys' => array(
      'id' => 'eid',
    ),   
  );
  // Notifications_Subscription
  $info['notifications_subscription'] = array(
    'label' => t('Subscription'),
    'controller class' => 'MessagingEntityController',
    'base class' => 'Notifications_Subscription_Instance',
    'base table' => 'notifications_subscription',
    'uri callback' => 'notifications_subscription_uri',
    'entity keys' => array(
      'id' => 'sid',
    ),
    'bundle keys' => array(
      'bundle' => 'sid',
    ),
    'bundles' => array(),
    'view modes' => array(
      // @todo View mode for display as a field (when attached to nodes etc).
      'full' => array(
        'label' => t('Subscriptions page'),
        'custom settings' => FALSE,
      ),
    ),
  );  
  return $info;
}

/**
 * Implementation of hook_cron_queue_info()
 */
/*
function notifications_cron_queue_info() {
  $queues['notifications_queue'] = array(
    'worker callback' => 'notifications_queue_cron_run',
    'time' => 60,
  );
  return $queues;
}
*/

/**
 * Implementation of hook_cron()
 */
function notifications_cron() {
  if (variable_get('notifications_process_on_cron', TRUE)) {
    $results = notifications_queue()
      ->default_process()
      ->cron()
      ->get_results();
    if ($results) {
      watchdog('notifications', 'Processed notifications in queue: @rows rows, @messages messages sent, @time milliseconds.', $results);
    }
  }
}

/**
 * Get information about event types. Invoking this function will also load the event API
 * 
 * @param $typekey
 *   Event type key
 * @param $property
 *   Property to return
 */
function notifications_event_type($typekey = NULL, $property = NULL, $default = NULL) {
  return notifications_info('event types', $typekey, $property, $default);
}

/**
 * Get info about object types
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 *   
 *   Information for a given field and type
 *   or information for a given field for all types
 */
function notifications_object_type($type = NULL, $field = NULL, $default = NULL) {
  return notifications_info('object types', $type, $field, $default);
}

/**
 * Build object
 */
/**
 * Get info about subscription types
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 */
function notifications_subscription_type($type = NULL, $field = NULL, $default = NULL) {
  return notifications_info('subscription types', $type, $field, $default);
}

/**
 * Load subscription type for menu operations
 */
function notifications_subscription_type_load($type) {
  return notifications_subscription($type);
}
/**
 * Get subscription type objects available for a user or current user
 */
function notifications_subscription_user_types($account = NULL) {
  $account = $account ? $account : $GLOBALS['user'];
  $types = array();
  foreach (notifications_subscription_enabled_types() as $type => $info) {
    $subscription = notifications_subscription($type);
    if ($subscription->user_access($account)) {
      $types[$type] = $subscription;
    }
  }
  return $types;
}

/**
 * Build subscription type object
 */
function notifications_subscription($type) {
  $subscription_types = &drupal_static(__FUNCTION__);
  if (!isset($subscription_types[$type])) {
    $class = notifications_subscription_type($type, 'class', 'Notifications_Subscription_Type');
    $subscription_types[$type] = new $class($type);
  }
  return $subscription_types[$type];
}

/**
 * Get info about templates
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 */
function notifications_template($type = NULL, $field = NULL) {
  $types = notifications_info('notifications templates');
  return messaging_array_info($types, $type, $field);
}

/*** Old code ****/


/**
 * Implementation of hook_permission()
 */
function notifications_permission() {
  return array(
    'administer notifications' =>  array(
      'title' => t('Administer notifications'),
      'description' => t('Administer all notifications options.'),
    ),
    'maintain own subscriptions' =>  array(
      'title' => t('Maintain own subscriptions'),
      'description' => t('Create, delete or edit own subscriptions.'),
    ),
    'manage all subscriptions' =>  array(
      'title' => t('Administer subscriptions'),
      'description' => t('Administer other subscriptions for other users.'),
    ),
    'skip notifications' => array(
      'title' => t('Skip notifications'),
      'description' => t('Make changes with an option to skip notifications when available.'),
    ),
  );
}

/**
 * Implementation of hook_user().
 */
function notifications_user_delete($user) {
  // Delete related data on tables
  Notifications_Subscription::delete_multiple(array('uid' => $user->uid));
}

/**
 * Implementation of hook_user().
 */
function notifications_user($type, $edit, $user, $category = NULL) {
  switch ($type) {
    case 'update':
      if (isset($edit['status'])) {
        if ($edit['status'] == 0) { // user is being blocked now
          // Delete pending notifications and block existing active subscriptions
          db_query('UPDATE {notifications_subscription} SET status = %d WHERE status = %d AND uid = %d', Notifications_Subscription::STATUS_BLOCKED, Notifications_Subscription::STATUS_ACTIVE, $user->uid);
          notifications_queue()->queue_clean(array('uid' => $user->uid));
        }
        else {
          // User may be being unblocked, unblock subscriptions if any
          db_query('UPDATE {notifications_subscription} SET status = %d WHERE status = %d AND uid = %d', Notifications_Subscription::STATUS_ACTIVE, Notifications_Subscription::STATUS_BLOCKED, $user->uid);
        }
      }
      break;
    case 'after_update':
      // Update language for all existing subscriptions
      if ($language = user_preferred_language($user)) {
        db_query("UPDATE {notifications_subscription} SET language = '%s' WHERE uid = %d", $language->language, $user->uid);
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter()
 */
function notifications_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    // Default send interval for user form
    case 'user_profile_form':
      if ($form['_category']['#value'] == 'account' && (user_access('maintain own subscriptions') || user_access('administer notifications'))) {
        $form['messaging']['#title'] = t('Messaging and Notifications settings');
        $send_intervals = notifications_send_intervals();
        $form['messaging']['notifications_send_interval'] = array(
          '#type' => 'select',
          '#title' => t('Default send interval'),
          '#options' => $send_intervals,
          '#default_value' => notifications_user_setting('send_interval', $form['_account']['#value']),
          '#disabled' => count($send_intervals) == 1,
          '#description' => t('Default send interval for subscriptions.'),
        );    
      }
  }
}

/**
 * Gets a user setting, defaults to default system setting for each
 * 
 * @param $name
 *   Setting name
 * @param $account
 *   Optional user account, will default to current user
 * @param $default
 *   Optional default to return if this is not set
 */
function notifications_user_setting($name, $account = NULL, $default = NULL) {
  global $user;

  $account = $account ? $account : $user;
  // Default send method is taken from messaging module
  if ($name == 'send_method') {
    return messaging_method_default($account);
  } 
  $field = 'notifications_'. $name;
  if (isset($account->$field)) {
    return $account->$field;
  }
  else {
    return variable_get('notifications_default_'. $name, $default);
  }
}

/**
 * Pass on event to queue processing and run it to the end
 * 
 * @param $event
 *   Array with event parameters
 * @param $objects
 *   Array of event objects (type => $object)
 */
function notifications_event($event, $objects = array()) {
  if (is_array($event)) {
    $event = Notifications_Event::create($event, $objects);
  }
  if ($event->save || $event->queue) {
    $event->trigger();   
  }
  return $event;
}

/**
 * Check whether we have enabled events of this type
 * 
 * @param $key
 *   Event type key
 * @param $default
 *   Default value to return if not set
 */
function notifications_event_enabled($key, $default = TRUE) {
  $info = variable_get('notifications_event_enabled', array());
  $status = isset($info[$key]) ? $info[$key] : $default;
  // If this has a parent type, will be enabled just if parent is
  if ($status && ($parent = notifications_event_type($key, 'parent'))) {
    return notifications_event_enabled($parent, FALSE);
  }
  else {
    return $status;
  }
}

/**
 * Implementation of hook_exit()
 * 
 * This is where the immediate sending is done if enabled, so we are sure all other modules
 * have finished node processing when node update.
 */
function notifications_exit() {
  // We don't load the function if not loaded, which means no events were triggered
  if (class_exists('Notifications_Event', FALSE)) {
    Notifications_Event::process_immediate();
  }
}

/**
 * Build subscription object properly
 * 
 * @param $subscription
 *   Subscription object, or array of properties or subscription type
 */
function notifications_build_subscription($subscription) {
  if (is_object($subscription) && is_a($subscription, 'Notifications_Subscription')) {
    return $subscription;
  }
  else {
    return Notifications_Subscription::build($subscription);
  }
}

/**
 * Update or create subscription
 * 
 * This function checks for duplicated subscriptions before saving.
 * If a similar subscription is found it will be updated.
 * If no subscription is found and it is new, the sid will be added into the object.
 * 
 * @param $subscription
 *   Subscription object or array
 * @param $check
 *   Whether to check parameters, can be skipped if they've been previously checked
 * @return integer
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or SAVED_UPDATED is returned depending on the operation performed.
 */
function notifications_save_subscription(&$subscription, $check = TRUE) {
  // Build object if not built previously
  $subscription = notifications_build_subscription($subscription);

  // Check all the parameters are ok, add error message and return if not
  if ($check && !notifications_check_subscription($subscription)) {
    return FALSE;
  }
  
  // Parameters are checked, now proceed
  if (!empty($subscription->sid)) {
    $op = 'update';
    $result = $subscription->save();
  }
  else {
    if ($duplicate = notifications_get_subscriptions(array('mdid' => $subscription->mdid, 'type' => $subscription->type, 'event_type' => $subscription->event_type, 'module' => $subscription->module, 'send_interval' => $subscription->send_interval), $subscription->get_conditions(), TRUE)) {
      // We've found duplicates, resolve conflict updating first, deleting the rest
      // It is possible that we had a disabled one, this updating will fix it
      $update = array_shift($duplicate);
      unset($subscription->sid); // It may be 0
      foreach ($subscription as $key => $value) {
        if (isset($value)) {
          $update->$key = $value;
        }
      }
      $subscription->sid = $update->sid;
      // If there are more, delete, keep the table clean
      while ($dupe = array_shift($duplicate)) {
        Notifications_Subscription::delete_subscription($dupe->sid);
      }
      return notifications_save_subscription($subscription, $check);  
    }
    else {
      $op = 'insert';    
      $result = $subscription->save();
    }
  }
  
  // If the operation has worked so far, update fields and inform other modules
  if ($result !== FALSE) {
    notifications_queue()->queue_init_subscription($subscription);
    module_invoke_all('notifications_subscription', $op, $subscription);
  }

  return $result;
}

/**
 * Shorthand function for deleting everything related to a destination
 */
function notifications_delete_destination($mdid) {
  Notifications_Subscription::delete_multiple(array('mdid' => $mdid));
  Messaging_Destination::delete_multiple(array('mdid' => $mdid));
}

/**
 * Create a wrapped object and keep a cache of created objects.
 * 
 * @param $type
 *   Object type
 * @parma $value
 *   Object or object key
 */
function notifications_object($type, $value) {
  $cache = &drupal_static(__FUNCTION__);
  $class = notifications_object_type($type, 'class', 'Notifications_Drupal_Object');
  if (is_object($value) && is_a($value, $class)) {
    // Already an instance of the right class, just return
    return $object;
  }
  elseif (is_numeric($value) || is_string($value)) {
    $key = $value;
  }
  if (isset($key) && isset($cache[$type][$key])) {
    return $cache[$type][$key];
  }
  else {
    $object = Notifications_Object::build($type, $value);
    // Not all objects are cacheable, only if they have a value
    if ($object->value) {
      $cache[$type][$object->value] = $object;
    }
    return $object;
  }
}

/**
 * Get info about subscription types
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 * @param $check_access
 *   Whether to check user access and filter out disabled types
 *   
 *   Information for a given field and type
 *   or information for a given field for all types
 */
function notifications_subscription_enabled_types($type = NULL, $field = NULL) {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    foreach (notifications_subscription_type() as $key => $info) {
      if (empty($info['disabled']) && notifications_subscription_type_enabled($key)) {
        $types[$key] = $info;
      }
    }
  }
  return messaging_array_info($types, $type, $field);
}

/**
 * Check if this type is enabled
 * 
 * The settings will be an array with type => type when enabled or type => 0 when disabled
 * 
 * @param $type
 *   Type to check, or nothing to return all
 * @param $setvalue
 *   Set this type as enabled (TRUE) / disabled (FALSE)
 */
function notifications_subscription_type_enabled($type = NULL, $setvalue = NULL) {
  // By using a static, modules can peek and change this settings for specific pages
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $types = variable_get('notifications_subscription_types', array());
    // For types not set, we assume enabled
    $type_keys = array_keys(notifications_subscription_type());
    $types += array_combine($type_keys, $type_keys);
  }
  if (isset($setvalue)) {
    $types[$type] = $setvalue ? $type : 0;
    variable_set('notifications_subscription_types', $types);
  }
  elseif ($type) {
    // If we don't have a setting yet for this type, return true
    return isset($types[$type]) ? (boolean)$types[$type] : TRUE;
  }
  else {
    // Return only the types enabled
    return array_filter($types);
  }
}

/**
 * Get information about subscriptions fields
 * 
 * Replaces notifications_field_type()
 */
function notifications_field_type($type = NULL, $property = NULL, $default = NULL) {
  $fields = notifications_info('field types');
  return messaging_array_info($fields, $type, $property, $default);
}

/**
 * Filter elements in an array of arrays/objects that match some condition
 * 
 * @param $array
 *   Data array to be filtered.
 * @param $filter
 *   Array of field => value pairs
 * @param $reverse
 *   Reverse filter, return elements that don't match
 */
function notifications_array_filter($array, $filter, $reverse = FALSE) { 
  if (!$filter) {
    return $array;
  }
  foreach ($array as $key => $data) {
    $compare = is_object($data) ? (array)$data : $data;
    $match = count(array_intersect_assoc($filter, $compare)) == count($filter);
    if ($match && $reverse || !$match && !$reverse) {
      unset($array[$key]);
    }
  }
  return $array;
}

/**
 * Array item callback to format title and description
 */
function notifications_format_title_description($item) {
  if (!empty($item['description'])) {
    $description = check_plain($item['description']);
  }
  elseif (!empty($item['name'])) {
    $description = check_plain($item['name']);
  } 
  return '<strong>' . check_plain($item['title']) . '</strong>' . (!empty($description) ? ' ' . $description : '');
}

/**
 * Serialize an array ordering the keys before.
 * 
 * This is useful for cache indexes and signatures.
 */
function notifications_array_serialize($array) {
  if (!$array) {
    return '';
  }
  // First we sort and serialize multiple conditions
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      asort($value);
      $array[$key] = implode(':', $value);
    }
  }
  // Now we sort the whole condtions array maintaining index association
  ksort($array);
  return implode(',', array_keys($array)) . '/' . implode(',', $array);  
}

/**
 * Implementation of hook_messaging()
 * 
 * This hook provides information about the mensaje templates this module uses and related tokens.
 * 
 * Depending on $op, this hook takes different parameters and returns different pieces of information:
 * 
 * - 'message groups'
 *   Get array of message groups, each of which will have one or more keys for different templates
 *   Each group should have a unique key, so it should start with the module name
 * - 'message keys'
 *   Get message template parts for a given group ($arg1)
 *   Return array of key => name for each part
 * - 'messages'
 *   Get default message templates for a given group ($arg1).
 *   It should return default texts, indexed by message key that will be the default templates
 *   These templates may be edited on the 'Messaging templates' page
 * - 'tokens'
 *   Get available tokens for a given message group and key ($arg1).
 *   Return array of token keys that will be available for this message templates
 *   The tokens themselves may be default tokens (provided by token module) or we can add new
 *   tokens implementing hook_token_list() and hook_token_value()
 * 
 * @param $op
 *   Operation, type of information to retrieve
 * @param $arg1, $arg2...
 *   Different parameters depending on $op
 */
function notifications_messaging($op, $arg1 = NULL, $arg2 = NULL) {
  switch ($op) {
    case 'message types':
      $info['notifications'] = array(
        'name' => t('Notifications'),
        'description' => t('Messages coming from user subscriptions and system events')
      );
      return $info;

    case 'method update':
      // A messaging method has been disabled ($arg1) and replaced by the new one ($arg2)
      notifications_include('destination.inc');
      notifications_destination_method_replace($arg1, $arg2);
      break;
  }
}

/**
 * Get event types. Invoking this function will also load the event API
 * 
 * Was: notifications_event_type_enabled
 */
function notifications_event_enabled_types($typekey = NULL, $property = NULL, $default = NULL) {
  $enabled = &drupal_static(__FUNCTION__);
  if (!isset($enabled)) {
    $enabled = array();
    foreach (notifications_event_type() as $type => $event_type) {
      if (empty($event['disabled']) && notifications_event_enabled($type)) {
        $enabled[$type] = $event_type;
      }
    }
  }
  return messaging_array_info($info, $typekey, $property, $default);
}

/**
 * Information about digesting method for a send interval.
 * 
 * @return array()
 *   Ditest information for that interval, or all the information if no interval
 */
function notifications_build_method($send_interval = NULL, $refresh = FALSE) {
  $build_methods = notifications_info('build methods', NULL, $refresh);
  $intervals = variable_get('notifications_digest_methods', array());

  if (is_null($send_interval)) {
    return $build_methods;
  }
  elseif (!empty($intervals[$send_interval]) && isset($build_methods[$intervals[$send_interval]])) {
    return $build_methods[$intervals[$send_interval]];
  }
  else {
    // Default, that will be always the simple one
    return $build_methods['simple'];
  }
}

/**
 * Invoke hook_notifications($name) on all modules
 * 
 * This is like module_invoke all with some differences:
 * - The results are just merged (not recursively)
 * - The module name is added to each resulting array
 * - We cache all the results 
 */
function notifications_info($name, $type = NULL, $property = NULL, $default = NULL) {
  $_name = strtr($name, ' ', '_');
  $info = &drupal_static('notifications_info_' . $_name);
  if (!isset($info)) {
    $info = module_invoke_all('notifications', $name);
    // Provide alter hook: notifications_name
    drupal_alter('notifications_' . $_name, $info);
  }      
  return messaging_array_info($info, $type, $property, $default);
}

/**
 * Get a option value for a given type from multiple variables
 */
function notifications_get_option($name, $type = NULL, $default = NULL) {
  $options = &drupal_static('notifications_options');
  if (!isset($options[$name])) {
    $options[$name] = variable_get('notifications_option_' . $name, array());
  }
  if ($type) {
    return isset($options[$name][$type]) ? $options[$name][$type] : $default;
  }
  else {
    return $options[$name];
  }
}

/**
 * Set an option value for a given type for multiple variables
 * 
 * If no type (NULL), set the full array
 */
function notifications_set_option($name, $type, $value) {
  notifications_get_option($name);
  $options = &drupal_static('notifications_options');
  if ($type) {
    $options[$name][$type] = $value;
  }
  else {
    $options[$name] = $value;
  } 
  variable_set('notifications_option_' . $name, $options[$name]);
}

/**
 * Entry point for the storage and queueing API
 * 
 * Default methods are implemented by Notifications_Queue class
 * 
 * This API can be replaced by setting a new class name in the 'notifications_queue' variable.
 */
function notifications_queue() {
  static $queue;
  if (!isset($queue)) {
    $class = variable_get('notifications_queue', 'Notifications_Queue');
    $queue = new $class();
  }
  //return call_user_func_array(array($class, $method), $args);
  return $queue;
}

/**
 * List of send intervals, translated.
 */
function notifications_send_intervals($account = NULL) {
  $list = &drupal_static(__FUNCTION__);
  if ($account && !$account->uid && function_exists('notifications_anonymous_send_intervals')) {
    return notifications_anonymous_send_intervals();
  }
  if (!isset($intervals)) {
    if ($intervals = variable_get('notifications_send_intervals', FALSE)) {
      foreach ($intervals as $key => $name) {
        $list[$key] = notifications_translate("send_interval:$key:name", $name);
      }
    }
    else {
      $list = _notifications_send_intervals();
    }
  }
  return $list;
}

/**
 * List of send intervals. These may be overriden in a variable.
 */
function _notifications_send_intervals() {
  return variable_get('notifications_send_intervals', array(
      // -1 => t('Never'),
      0 => t('Immediately'),
      3600 => t('Every hour'),
      43200 => t('Twice a day'),
      86400 => t('Daily'),
      604800 => t('Weekly'),  
    )
  );
}

/**
 * Get list of send methods for user or anonymous account
 */
function notifications_send_methods($account) {
  // We restrict send methods for anonymous accounts when edited by regular users
  if (empty($account->uid) && function_exists('notifications_anonymous_send_methods')) {
    return notifications_anonymous_send_methods();
  }
  else {
    return _notifications_send_methods($account);
  }
}

/**
 * List of send methods
 * 
 * @param $account
 *   Optional user account, for checking permissions against this account
 */
function _notifications_send_methods($account = NULL) {
  return variable_get('notifications_send_methods', messaging_method_list($account));
}

/**
 * Implementation of hook_theme()
 */
function notifications_theme() {
  return array(
    'notifications_send_intervals_form' => array(
      'render_element' => 'element',
      'file' => 'notifications.admin.inc',
    ),
    'notifications_manage_subscriptions' => array(
      'render_element' => 'form',
      'file' => 'notifications.manage.inc',
    ),
    'notifications_subscriptions_filter_form' => array(
      'render_element' => 'form',
      'file' => 'notifications.manage.inc',
    ),
    'notifications_table_form' => array(
      'render_element' => 'form',
      'file' => 'notifications.pages.inc',
    ),
    'notifications_subscription_fields' => array(
      'render_element' => 'element',
      'file' => 'notifications.pages.inc',
    ),
  );
}

/**
 * Implementation of hook_forms()
 */
function notifications_forms($form_id, $args) {
  $forms['notifications_subscription_add_form'] = array(
    'callback' => 'notifications_subscription_form',
    'callback arguments' => 'add',
  );
  $forms['notifications_subscription_edit_form'] = array(
    'callback' => 'notifications_subscription_form',
    'callback arguments' => 'edit',
  );
  $forms['notifications_subscription_confirm_form'] = array(
    'callback' => 'notifications_subscription_form',
    'callback arguments' => 'confirm',
  );
  return $forms;
}

/**
 * Subscription form ('add', 'edit', 'confirm')
 */
function notifications_subscription_form($form, &$form_state, $op, $subscription) {
  return $subscription->get_form($op, $form, $form_state);
}
/**
 * Validate form submission
 */
function notifications_subscription_form_validate($form, &$form_state) {
  return Notifications_Subscription::build_from_submission($form, $form_state)->form_validate($form, $form_state);
}
/**
 * Process form submission
 */
function notifications_subscription_form_submit($form, &$form_state) {
  return Notifications_Subscription::build_from_submission($form, $form_state)->form_submit($form, $form_state);
}

/**
 * Wrapper for l() function with some more options
 */
function notifications_l($text, $path, $options = array()) {
  return l($text, $path, notifications_url_options($path, $options));
}
/**
 * Wrapper for url() function with some more options
 */
function notifications_url($path, $options = array()) {
  return url($path, notifications_url_options($path, $options));
}

/**
 * Fill some url options
 */
/**
 * Wrapper for url() function with some more options
 */
function notifications_url_options($path, $options = array()) {
  $options += array(
    'skip_confirmation' => FALSE,
    'query' => array(),
  );
  // If skip confirmation, links need to be signed
  $options += array('signed' => $options['skip_confirmation']);
  // If signed, add timestamp and signature, and maybe skip confirmation
  if ($options['signed']) {
    $options['query'] += array('timestamp' => REQUEST_TIME);
    if ($options['skip_confirmation']) {
      $options['query']['skip'] = 1;
    }
    $options['query']['signature'] = notifications_url_signature($path, $options['query']);
  }
  return $options;
}

/**
 * Signature for url parameters
 * 
 * @param $path
 *   Path or array with path elements
 * @param $query
 *   Query string elements
 */
function notifications_url_signature($path, $query = array()) {
  $path = is_array($path) ? implode('/', $path) : $path;
  if (isset($query['signature'])) {
    unset($query['signature']);
  }
  $string = $query ? notifications_array_serialize($query) : 'none'; 
  return md5('notifications' . drupal_get_private_key() .':' . $path . ':' . $string); 
}

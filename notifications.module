<?php
// $Id: notifications.module,v 1.6.2.9.2.50.2.18.2.67 2010/07/22 11:57:49 jareyero Exp $

/**
 * @file
 * Notifications module
 *
 * This is the base module of the notifications framework. It handles event processing, queueing,
 * message composition and sending.
 * 
 * Different subscriptions types are provided by plug-in modules implementing hook_notifications()
 * Most of the UI is implemented in notifications_ui module
 * The messaging framework is used for message delivery
 * Token module is used for token replacement in messages 
 * 
 * This is based on the previous subscriptions module
 * 
 * Development Seed, http://www.developmentseed.org, 2007 
 *
 */

// Format as plaintext. Note it evaluates to false.
define('NOTIFICATIONS_FORMAT_PLAIN', 0);
// Format as html. Note it evaluates to true
define('NOTIFICATIONS_FORMAT_HTML', 1);
// Format inline, as a string of csv
define('NOTIFICATIONS_FORMAT_INLINE', 2);
// Format as HTML table (4 +1)
define('NOTIFICATIONS_FORMAT_TABLE', 5);
// Format as item list (8 + 2(inline) + 1 (html))
define('NOTIFICATIONS_FORMAT_LIST', 10);

/**
 * Implementation of hook_menu().
 */
function notifications_menu() {
  // Administration. This one will override messaging menu item
  $items['admin/config/messaging'] = array(
    'title' => 'Messaging & Notifications',
    'access arguments' => array('administer notifications'),
    'description' => 'Administer and configure messaging and notifications',
    'page callback' => 'system_admin_menu_block_page',
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  // Notifications and Subscription settings
  $items['admin/config/messaging/notifications'] = array(
    'title' => 'Notifications settings',
    'description' => 'Configuration for Subscriptions and Notifications.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
  );
  $items['admin/config/messaging/notifications/settings'] = array(
    'title' => 'Main',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'notifications.admin.inc',
  );
  $items['admin/config/messaging/notifications/intervals'] = array(
    'title' => 'Intervals',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_send_intervals_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
  );
  $items['admin/config/messaging/notifications/events'] = array(
    'title' => 'Events',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_admin_events_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
  );

  $items['admin/config/messaging/notifications/subscriptions'] = array(
    'title' => 'Subscriptions',
    'description' => 'Subscriptions settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_admin_subscriptions_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'notifications.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/messaging/notifications/subscriptions/types'] = array(
    'title' => 'Options',
    'description' => 'Subscription options.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Subscribe links. For this items access will be checked later in the page
  $items['notifications/subscribe/%user'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'notifications_page_subscribe',
    'page arguments' => array(2),
    'access callback' => 'notifications_access_subscribe',
    'access arguments' => array(2),
    'file' => 'notifications.pages.inc',
  );
  // Unsubscribe links This page will need to work with anonymous users
  $items['notifications/unsubscribe'] = array(
    'type' => t('Unsubscribe'),
    'page callback' => 'notifications_page_unsubscribe',
    'access callback' => TRUE,
    'file' => 'notifications.pages.inc',
  );
  // Edit subscription, stand alone page
  $items['notifications/subscription/%notifications_subscription'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Edit subscription',
    'page callback' => 'notifications_subscription_edit_page',
    'page arguments' => array(2),
    'access callback' => 'notifications_subscription_access',
    'access arguments' => array('edit', 2),
    'file' => 'notifications.pages.inc',
  );
  // Manage destinations
  $items['notifications/destination/%messaging_destination/edit'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Edit destination',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_edit_destination_form', 2),
    'access callback' => 'notifications_destination_access',
    'access arguments' => array('edit', 2),
    'file' => 'notifications.manage.inc',
  );
  $items['notifications/destination/%messaging_destination/manage'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Manage destination',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_manage_destination_form', 2),
    'access callback' => 'notifications_destination_access',
    'access arguments' => array('manage', 2),
    'file' => 'notifications.manage.inc',
  );
  // User account tabs
  $items['user/%user/notifications'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Notifications',
    //'page callback' => 'notifications_page_user_overview',
    //'page arguments' => array(1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_user_overview', 1),
    'access callback' => 'notifications_access_user',
    'access arguments' => array(1),
    'file' => 'notifications.pages.inc',
  );
  $items['user/%user/notifications/overview'] = array(
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'title' => 'Overview',
    'weight' => -10,
  );  
  $items['user/%user/notifications/subscriptions'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Subscriptions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_manage_user_subscriptions', 1),
    'access callback' => 'notifications_access_user',
    'access arguments' => array(1, 'manage'),
    'file' => 'notifications.manage.inc',
  );
  // Edit subscription under subscriptions tab
  $items['user/%user/notifications/subscriptions/edit/%notifications_subscription'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Edit subscription',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_subscription_edit_form', 5),
    'access callback' => 'notifications_subscription_access',
    'access arguments' => array('edit', 5),
    'file' => 'notifications.pages.inc',
  );
  // Delete subscription under subscriptions tab
  $items['user/%user/notifications/subscriptions/delete/%notifications_subscription'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Delete subscription',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_form_unsubscribe_confirm', 5),
    'access callback' => 'notifications_subscription_access',
    'access arguments' => array('unsubscribe', 5),
    'file' => 'notifications.pages.inc',
  );
  $items['user/%user/notifications/update/%'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Update subscriptions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_update_user_subscriptions', 1, 4),
    'access callback' => 'notifications_access_user',
    'access arguments' => array(1, 'maintain'),
    'file' => 'notifications.pages.inc',
  );  
  // Some autocomplete callbacks
  $items['notifications/autocomplete/node/title'] = array(
    'title' => 'Node title autocomplete',
    'page callback' => 'notifications_node_autocomplete_title',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/node.inc',
  );
  // Some autocomplete callbacks
  $items['notifications/autocomplete/node/type'] = array(
    'title' => 'Node title autocomplete',
    'page callback' => 'notifications_node_autocomplete_type',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/node.inc',
  );
  // Manage existing subscriptions
  $items['admin/messaging/subscriptions'] = array(
    'title' => 'Manage subscriptions',
    'description' => 'Manage existing subscriptions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_admin_manage_subscriptions'),
    'access arguments' => array('administer notifications'),
    'file' => 'notifications.admin.inc',
  ); 

  $items['admin/messaging/subscriptions/admin'] = array(
    'title' => 'Administer',
    'description' => 'Administer subscriptions.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer notifications'),
  );
  $items['admin/messaging/subscriptions/status'] = array(
    'title' => 'Status',
    'description' => 'Summary of existing subscriptions.',
    'page callback' => 'notifications_admin_status_page',
    'access arguments' => array('administer notifications'),
    'file' => 'notifications.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Menu access callback for user subscriptions
 * 
 * @param $account
 *   User account to which these subscriptions below
 * @param $op
 *   - maintain = create / delete
 *   - manage = use the per account administration page
 */
function notifications_access_user($account, $op = 'maintain') {
  global $user;
  
  if (user_access('administer notifications') || user_access('manage all subscriptions')) {
    return TRUE;
  }
  else {
    return $account->uid && $user->uid == $account->uid &&
      (($op == 'maintain' && user_access('maintain own subscriptions')) || ($op == 'manage' && user_access('manage own subscriptions')));
  }
}

/**
 * Menu access callback, add a given subscription type
 */
function notifications_access_user_add($account = NULL, $type = NULL) {
  global $user;
  
  $account = $account ? $account : $user;  
  if (notifications_access_user($account)) {
    if ($type && ($access = notifications_subscription_types($type, 'access'))) {
      return user_access($access, $account);
    }
    else {
      return TRUE;
    }
  }
}

/**
 * Check signature
 * 
 * @param $params
 *   Optional array of path elements. If not specified the current URL will be used
 * @param $query
 *   Query string array, will be taken from request if empty
 * @param $prefix
 *   When using the path this must match the first part of it, which is not used in the signature
 */
function notifications_check_signature($params = NULL, $query = array(), $prefix = 'notifications') {
  // If not parameters passed, get them from path, discard the first one that must match $prefix
  if (!$params) {
    if (arg(0) == $prefix) {
      $params = arg();
      array_shift($params);
    }
    $query = $query ? $query : $_GET;
  }
  // Check timestamp < 7 days
  if (!empty($query['timestamp']) && time() - 24 * 7 * 3600 > (int)$query['timestamp']) {
    drupal_set_message(t('This link has expired. Please get a new one or contact the site administrator.'), 'error');
    return FALSE;
  }
  if (!empty($_GET['signature'])) {
    unset($query['signature']);
    unset($query['q']);
    if ($_GET['signature'] === _notifications_signature($params, $query)) {
      return TRUE;
    }
    else {
      drupal_set_message(t('This link is not valid anymore. Please get a new one or contact the site administrator.'), 'error');
      return FALSE;
    }
  }
}

/**
 * Menu access callback for subscribe links
 * 
 * More access checking depending on subscription type will be done at the destination page
 */
function notifications_access_subscribe($account) {
  global $user;
  
  if (!$account->uid && !$user->uid) return notifications_access_anonymous();
  
  if (user_access('administer notifications') || user_access('manage all subscriptions')) return TRUE;
  
  return $account && $account->uid && ($user->uid == $account->uid) && user_access('maintain own subscriptions');
}

/**
 * Check access for anonymous subscriptions
 */
function notifications_access_anonymous() {
  static $access;
  if (!isset($access)) {
    $access = module_exists('notifications_anonymous') && notifications_anonymous_send_methods() && notifications_anonymous_send_intervals();
  }
  return $access;
}

/**
 * Menu loading, subscription
 */
function notifications_subscription_load($sid) {
  return Notifications_Subscription_Instance::load($sid);
}

/**
 * Menu access callback
 */
function notifications_subscription_access($op, $subscription, $account = NULL) {
  global $user;

  $account = $account ? $account : $user;  
  if (user_access('administer notifications') || user_access('manage all subscriptions')) {
    return TRUE;
  } 
  switch ($op) {
    case 'edit':
    case 'unsubscribe':
      return $subscription->uid && ($subscription->uid == $account->uid) && user_access('maintain own subscriptions');
  }
  return FALSE;
}

/**
 * Menu access callback for destinations
 */
function notifications_destination_access($op, $destination) {  
  // Access will be granted only to administrator for now
  return user_access('administer notifications');
}

/**
 * Implements hook_entity_info().
 */
function notifications_entity_info() {
  // Notifications_Event
  $info['notifications_event'] = array(
    'label' => t('Event'),
    'controller class' => 'MessagingEntityController',
    'base class' => 'Notifications_Event',
    'base table' => 'notifications_event',
    'entity keys' => array(
      'id' => 'eid',
    ),   
  );
  // Notifications_Subscription
  $info['notifications_subscription'] = array(
    'label' => t('Subscription'),
    'controller class' => 'MessagingEntityController',
    'base class' => 'Notifications_Subscription_Instance',
    'base table' => 'notifications',
    'uri callback' => 'notifications_subscription_uri',
    'entity keys' => array(
      'id' => 'sid',
    ),
    'bundle keys' => array(
      'bundle' => 'sid',
    ),
    'bundles' => array(),
    'view modes' => array(
      // @todo View mode for display as a field (when attached to nodes etc).
      'full' => array(
        'label' => t('Subscriptions page'),
        'custom settings' => FALSE,
      ),
    ),
  );  
  return $info;
}

/**
 * Implementation of hook_cron_queue_info()
 */
/*
function notifications_cron_queue_info() {
  $queues['notifications_queue'] = array(
    'worker callback' => 'notifications_queue_cron_run',
    'time' => 60,
  );
  return $queues;
}
*/

/**
 * Implementation of hook_cron()
 */
function notifications_cron() {
  if (variable_get('notifications_process_on_cron', TRUE)) {
    $results = notifications_queue()
      ->default_process()
      ->cron()
      ->get_results();
    if ($results) {
      watchdog('notifications', 'Processed notifications in queue: @rows rows, @messages messages sent, @time milliseconds.', $results);
    }
  }
}

/**
 * Get information about event types. Invoking this function will also load the event API
 * 
 * @param $typekey
 *   Event type key
 * @param $property
 *   Property to return
 */
function notifications_event_type($typekey = NULL, $property = NULL, $default = NULL) {
  $info = &notifications_info('event types');
  return messaging_array_info($enabled, $typekey, $property);
}

/**
 * Get info about object types
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 *   
 *   Information for a given field and type
 *   or information for a given field for all types
 */
function notifications_object_type($type = NULL, $field = NULL, $default = NULL) {
  $types = notifications_info('object types');
  return messaging_array_info($types, $type, $field, $default);
}

/**
 * Build object
 */
/**
 * Get info about subscription types
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 */
function notifications_subscription_type($type = NULL, $field = NULL, $default = NULL) {
  $types = notifications_info('subscription types');
  return messaging_array_info($types, $type, $field, $default);
}

/**
 * Get subscription types available for a user account
 */
function notifications_subscription_user_types($account = NULL) {
  $account = $account ? $account : $GLOBALS['user'];
  $types = array();
  foreach (notifications_subscription_enabled_types() as $type => $info) {
    if (notifications_subscription($type)->user_access($account)) {
      $types[$type] = $info;
    }
  }
  return $types;
}

/**
 * Build subscription type
 */
function notifications_subscription($type) {
  $subscription_types = &drupal_static(__FUNCTION__);
  if (!isset($subscription_types[$type])) {
    $subscription_types[$type] = Notifications_Subscription_Type::build($type);
  }
  return $subscription_types[$type];
}

/**
 * Get info about templates
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 */
function notifications_template($type = NULL, $field = NULL) {
  $types = notifications_info('notifications templates');
  return messaging_array_info($types, $type, $field);
}

/*** Old code ****/


/**
 * Implementation of hook_permission()
 */
function notifications_permission() {
  return array(
    'administer notifications' =>  array(
      'title' => t('Administer notifications'),
      'description' => t('Administer all notifications options.'),
    ),
    'maintain own subscriptions' =>  array(
      'title' => t('Maintain own subscriptions'),
      'description' => t('Create, delete or edit own subscriptions.'),
    ),
    'manage own subscriptions' =>  array(
      'title' => t('Manage own subscriptions'),
      'description' => t('Access the subscriptions management tab to view and edit own subscriptions.'),
    ),
    'manage all subscriptions' =>  array(
      'title' => t('Administer subscriptions'),
      'description' => t('Administer other subscriptions for other users.'),
    ),
    'skip notifications' => array(
      'title' => t('Skip notifications'),
      'description' => t('Make changes with an option to skip notifications when available.'),
    ),
  );
}

/**
 * Implementation of hook_user().
 */
function notifications_user($type, $edit, $user, $category = NULL) {
  switch ($type) {
    case 'delete';
      // Delete related data on tables
      notifications_delete_subscriptions(array('uid' => $user->uid));
      break;
    case 'update':
      if (isset($edit['status'])) {
        if ($edit['status'] == 0) { // user is being blocked now
          // Delete pending notifications and block existing active subscriptions
          db_query('UPDATE {notifications_subscription} SET status = %d WHERE status = %d AND uid = %d', Notifications_Subscription::STATUS_BLOCKED, Notifications_Subscription::STATUS_ACTIVE, $user->uid);
          notifications_queue()->queue_clean(array('uid' => $user->uid));
        }
        else {
          // User may be being unblocked, unblock subscriptions if any
          db_query('UPDATE {notifications_subscription} SET status = %d WHERE status = %d AND uid = %d', Notifications_Subscription::STATUS_ACTIVE, Notifications_Subscription::STATUS_BLOCKED, $user->uid);
        }
      }
      break;
    case 'after_update':
      // Update language for all existing subscriptions
      if ($language = user_preferred_language($user)) {
        db_query("UPDATE {notifications_subscription} SET language = '%s' WHERE uid = %d", $language->language, $user->uid);
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter()
 */
function notifications_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    // Default send interval for user form
    case 'user_profile_form':
      if ($form['_category']['#value'] == 'account' && (user_access('maintain own subscriptions') || user_access('administer notifications'))) {
        $form['messaging']['#title'] = t('Messaging and Notifications settings');
        $send_intervals = notifications_send_intervals();
        $form['messaging']['notifications_send_interval'] = array(
          '#type' => 'select',
          '#title' => t('Default send interval'),
          '#options' => $send_intervals,
          '#default_value' => notifications_user_setting('send_interval', $form['_account']['#value']),
          '#disabled' => count($send_intervals) == 1,
          '#description' => t('Default send interval for subscriptions.'),
        );    
      }
  }
}

/**
 * Implementation of hook_forms()
 */
function notifications_forms() {
  $forms['notifications_subscription_add_form']['callback'] = 'notifications_subscription_form';
  $forms['notifications_subscription_edit_form']['callback'] = 'notifications_subscription_form';
  $forms['notifications_subscription_confirm_form']['callback'] = 'notifications_subscription_form';
  return $forms;
}

/**
 * Gets a user setting, defaults to default system setting for each
 * 
 * @param $name
 *   Setting name
 * @param $account
 *   Optional user account, will default to current user
 * @param $default
 *   Optional default to return if this is not set
 */
function notifications_user_setting($name, $account = NULL, $default = NULL) {
  global $user;

  $account = $account ? $account : $user;
  // Default send method is taken from messaging module
  if ($name == 'send_method') {
    return messaging_method_default($account);
  } 
  $field = 'notifications_'. $name;
  if (isset($account->$field)) {
    return $account->$field;
  }
  else {
    return variable_get('notifications_default_'. $name, $default);
  }
}

/**
 * Pass on event to queue processing and run it to the end
 * 
 * @param $event
 *   Array with event parameters
 * @param $objects
 *   Array of event objects (type => $object)
 */
function notifications_event($event, $objects = array()) {
  if (is_array($event)) {
    $event = Notifications_Event::create($event, $objects);
  }
  if ($event->save || $event->queue) {
    $event->trigger();   
  }
  return $event;
}

/**
 * Check whether we have enabled events of this type
 * 
 * @param $key
 *   Event type key
 * @param $default
 *   Default value to return if not set
 */
function notifications_event_enabled($key, $default = TRUE) {
  $info = variable_get('notifications_event_enabled', array());
  $status = isset($info[$key]) ? $info[$key] : $default;
  // If this has a parent type, will be enabled just if parent is
  if ($status && ($parent = notifications_event_types($key, 'parent'))) {
    return notifications_event_enabled($parent, FALSE);
  }
  else {
    return $status;
  }
}

/**
 * Implementation of hook_exit()
 * 
 * This is where the immediate sending is done if enabled, so we are sure all other modules
 * have finished node processing when node update.
 */
function notifications_exit() {
  // We don't load the function if not loaded, which means no events were triggered
  if (class_exists('Notifications_Event', FALSE)) {
    Notifications_Event::process_immediate();
  }
}

/**
 * Build subscription object properly
 * 
 * @param $subscription
 *   Subscription object, or array of properties or subscription type
 */
function notifications_build_subscription($subscription) {
  if (is_object($subscription) && is_a($subscription, 'Notifications_Subscription')) {
    return $subscription;
  }
  else {
    return Notifications_Subscription::build($subscription);
  }
}

/**
 * Update or create subscription
 * 
 * This function checks for duplicated subscriptions before saving.
 * If a similar subscription is found it will be updated.
 * If no subscription is found and it is new, the sid will be added into the object.
 * 
 * @param $subscription
 *   Subscription object or array
 * @param $check
 *   Whether to check parameters, can be skipped if they've been previously checked
 * @return integer
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or SAVED_UPDATED is returned depending on the operation performed.
 */
function notifications_save_subscription(&$subscription, $check = TRUE) {
  // Build object if not built previously
  $subscription = notifications_build_subscription($subscription);

  // Check all the parameters are ok, add error message and return if not
  if ($check && !notifications_check_subscription($subscription)) {
    return FALSE;
  }
  
  // Parameters are checked, now proceed
  if (!empty($subscription->sid)) {
    $op = 'update';
    $result = $subscription->save();
  }
  else {
    if ($duplicate = notifications_get_subscriptions(array('mdid' => $subscription->mdid, 'type' => $subscription->type, 'event_type' => $subscription->event_type, 'module' => $subscription->module, 'send_interval' => $subscription->send_interval), $subscription->get_conditions(), TRUE)) {
      // We've found duplicates, resolve conflict updating first, deleting the rest
      // It is possible that we had a disabled one, this updating will fix it
      $update = array_shift($duplicate);
      unset($subscription->sid); // It may be 0
      foreach ($subscription as $key => $value) {
        if (isset($value)) {
          $update->$key = $value;
        }
      }
      $subscription->sid = $update->sid;
      // If there are more, delete, keep the table clean
      while ($dupe = array_shift($duplicate)) {
        notifications_subscription_delete($dupe->sid);
      }
      return notifications_save_subscription($subscription, $check);  
    }
    else {
      $op = 'insert';    
      $result = $subscription->save();
    }
  }
  
  // If the operation has worked so far, update fields and inform other modules
  if ($result !== FALSE) {
    notifications_queue()->queue_init_subscription($subscription);
    module_invoke_all('notifications_subscription', $op, $subscription);
  }

  return $result;
}

/**
 * Shorthand function for deleting everything related to a destination
 */
function notifications_delete_destination($mdid) {
  notifications_delete_subscriptions(array('mdid' => $mdid));
  Messaging_Destination::delete_multiple(array('mdid' => $mdid));
}

/**
 * Create a wrapped object and keep a cache of created objects.
 * 
 * @param $type
 *   Object type
 * @parma $value
 *   Object or object key
 */
function notifications_object($type, $value) {
  $cache = &drupal_static(__FUNCTION__);
  $class = notifications_object_type($type, 'class', 'Notifications_Drupal_Object');
  if (is_object($value) && is_a($value, $class)) {
    // Already an instance of the right class, just return
    return $object;
  }
  elseif (is_numeric($value) || is_string($value)) {
    $key = $value;
  }
  if (isset($key) && isset($cache[$type][$key])) {
    return $cache[$type][$key];
  }
  else {
    $object = Notifications_Object::build($type, $value);
    // Not all objects are cacheable, only if they have a value
    if ($object->value) {
      $cache[$type][$object->value] = $object;
    }
    return $object;
  }
}

/**
 * Load an object of type defined by notifications 'object types'
 * 
 * @param $type
 *   Object type
 * @param $value
 *   Object key value, or the object itself
 */
function notifications_object_load($type, $value) {
  if (is_object($value)) {
    return $value;
  }
  else {
    return _notifications_object_callback($type, 'load callback', $value);
  }
}

/**
 * Get info about subscription types
 *
 * @param $type
 *   String, the subscriptions type OPTIONAL
 * @param $field
 *   String, a specific field to retrieve info from OPTIONAL
 * @param $check_access
 *   Whether to check user access and filter out disabled types
 *   
 *   Information for a given field and type
 *   or information for a given field for all types
 */
function notifications_subscription_enabled_types($type = NULL, $field = NULL) {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    foreach (notifications_subscription_type() as $key => $info) {
      if (empty($info['disabled']) && notifications_subscription_type_enabled($key)) {
        $types[$key] = $info;
      }
    }
  }
  return messaging_array_info($types, $type, $field);
}

/**
 * Check if this type is enabled
 * 
 * The settings will be an array with type => type when enabled or type => 0 when disabled
 * 
 * @param $type
 *   Type to check, or nothing to return all
 * @param $setvalue
 *   Set this type as enabled (TRUE) / disabled (FALSE)
 */
function notifications_subscription_type_enabled($type = NULL, $setvalue = NULL) {
  // By using a static, modules can peek and change this settings for specific pages
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $types = variable_get('notifications_subscription_types', array());
    // For types not set, we assume enabled
    $type_keys = array_keys(notifications_subscription_types());
    $types += array_combine($type_keys, $type_keys);
  }
  if (isset($setvalue)) {
    $types[$type] = $setvalue ? $type : 0;
    variable_set('notifications_subscription_types', $types);
  }
  elseif ($type) {
    // If we don't have a setting yet for this type, return true
    return isset($types[$type]) ? (boolean)$types[$type] : TRUE;
  }
  else {
    // Return only the types enabled
    return array_filter($types);
  }
}

/**
 * Get information about subscriptions fields
 * 
 * Replaces notifications_field_type()
 */
function notifications_field_type($type = NULL, $property = NULL, $default = NULL) {
  $fields = notifications_info('field types');
  return messaging_array_info($fields, $type, $property, $default);
}

/**
 * Filter elements in an array of arrays/objects that match some condition
 * 
 * @param $array
 *   Data array to be filtered.
 * @param $filter
 *   Array of field => value pairs
 * @param $reverse
 *   Reverse filter, return elements that don't match
 */
function notifications_array_filter($array, $filter, $reverse = FALSE) { 
  if (!$filter) {
    return $array;
  }
  foreach ($array as $key => $data) {
    $compare = is_object($data) ? (array)$data : $data;
    $match = count(array_intersect_assoc($filter, $compare)) == count($filter);
    if ($match && $reverse || !$match && !$reverse) {
      unset($array[$key]);
    }
  }
  return $array;
}

/**
 * Array item callback to format title and description
 */
function notifications_format_title_description($item) {
  if (!empty($item['description'])) {
    $description = check_plain($item['description']);
  }
  elseif (!empty($item['name'])) {
    $description = check_plain($item['name']);
  } 
  return '<strong>' . check_plain($item['title']) . '</strong>' . (!empty($description) ? ' ' . $description : '');
}

/**
 * Serialize an array ordering the keys before.
 * 
 * This is useful for cache indexes and signatures.
 */
function notifications_array_serialize($array) {
  if (!$array) {
    return '';
  }
  // First we sort and serialize multiple conditions
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      asort($value);
      $array[$key] = implode(':', $value);
    }
  }
  // Now we sort the whole condtions array maintaining index association
  ksort($array);
  return implode(',', array_keys($array)) . '/' . implode(',', $array);  
}

/**
 * Implementation of hook_messaging()
 * 
 * This hook provides information about the mensaje templates this module uses and related tokens.
 * 
 * Depending on $op, this hook takes different parameters and returns different pieces of information:
 * 
 * - 'message groups'
 *   Get array of message groups, each of which will have one or more keys for different templates
 *   Each group should have a unique key, so it should start with the module name
 * - 'message keys'
 *   Get message template parts for a given group ($arg1)
 *   Return array of key => name for each part
 * - 'messages'
 *   Get default message templates for a given group ($arg1).
 *   It should return default texts, indexed by message key that will be the default templates
 *   These templates may be edited on the 'Messaging templates' page
 * - 'tokens'
 *   Get available tokens for a given message group and key ($arg1).
 *   Return array of token keys that will be available for this message templates
 *   The tokens themselves may be default tokens (provided by token module) or we can add new
 *   tokens implementing hook_token_list() and hook_token_value()
 * 
 * @param $op
 *   Operation, type of information to retrieve
 * @param $arg1, $arg2...
 *   Different parameters depending on $op
 */
function notifications_messaging($op, $arg1 = NULL, $arg2 = NULL) {
  switch ($op) {
    case 'message types':
      $info['notifications'] = array(
        'name' => t('Notifications'),
        'description' => t('Messages coming from user subscriptions and system events')
      );
      return $info;

    case 'message groups':
    case 'message keys':
    case 'messages':
    case 'tokens':
      notifications_include('templates.inc');
      return notifications_messaging_templates($op, $arg1, $arg2);

    case 'method update':
      // A messaging method has been disabled ($arg1) and replaced by the new one ($arg2)
      notifications_include('destination.inc');
      notifications_destination_method_replace($arg1, $arg2);
      break;
  }
}

/**
 * Implementation of hook_token_values()
 * 
 * @ TODO: Work out event tokens
 */
function notifications_token_values($type, $object = NULL, $options = array()) {
  $language = isset($options['language']) ? $options['language'] : $GLOBALS['language'];
  switch ($type) {
    case 'subscription':
      $values = array();
      // Tokens only for registered users
      if ($subscription = messaging_check_object($object, 'Notifications_Subscription')) {
        $values['subscription-unsubscribe-url'] = notifications_build_url('unsubscribe', 'subscription', $subscription, array('language' => $language));
        $values['subscription-edit-url'] = notifications_build_url('edit', 'subscription', $subscription, array('language' => $language));
        $values['subscription-type'] = $subscription->get_type('name');
        $values['subscription-name'] = $subscription->get_name();
        $values['subscription-description-short'] = $subscription->format_short(FALSE);
        $values['subscription-description-long'] = $subscription->format_long(FALSE);
        // Old token, populate it for old templates
        $values['unsubscribe-url'] = $values['subscription-unsubscribe-url'];
      }
      return $values;
      
    case 'user':
      // Only for registered users.
      if (($account = $object) && !empty($account->uid)) {
        // We have a real user, so we produce full links
        $values['subscriptions-manage'] = url("user/$account->uid/notifications", array('absolute' => TRUE, 'language' => $language));
        $values['unsubscribe-url-global'] = notifications_build_url('unsubscribe', 'user', $account, array('language' => $language));
        return $values;
      }
      break;

    case 'destination':
      // These are just for registered users. For anonymous, notifications_anonymous will do it
      if (($destination = messaging_check_object($object, 'Messaging_Destination')) && !empty($destination->uid)) {
        $values['destination-unsubscribe-url'] = notifications_build_url('unsubscribe', 'destination', $destination, array('language' => $language));
        $values['destination-manage-url'] = notifications_build_url('manage', 'destination', $destination, array('language' => $language));
        $values['destination-edit-url'] = notifications_build_url('edit', 'destination', $destination, array('language' => $language));
        return $values;
      }
      break;

    case 'event':
      if ($event = messaging_check_object($object, 'Notifications_Event')) {
        $timezone = isset($options['timezone']) ? $options['timezone'] : variable_get('date_default_timezone', 0);
        $values['event-type-description'] = $event->get_type('description');
        $values['event-date-small'] = format_date($event->created, 'small', '', $timezone, $language->language);
        $values['event-date-medium'] = format_date($event->created, 'medium', '', $timezone, $language->language);
        $values['event-date-large'] = format_date($event->created, 'large', '', $timezone, $language->language);
        return $values;
      }
      break;
  }
}

/**
 * Implementation of hook_token_list(). Documents the individual
 * tokens handled by the module.
 */
function notifications_token_list($type = 'all') {
  $tokens = array();
  if ($type == 'user' || $type == 'all') {
    $tokens['user']['subscriptions-manage']    = t('The url for the current user to manage subscriptions.');
    $tokens['user']['unsubscribe-url-global'] = t('The url to allow a user to delete all their subscriptions.');
  }
  if ($type == 'subscription' || $type == 'all') {
    $tokens['subscription']['subscription-unsubscribe-url']  = t('The url for disabling a specific subscription.');
    $tokens['subscription']['subscription-edit-url']  = t('The url for editing a specific subscription.');
    $tokens['subscription']['subscription-type'] = t('The subscription type.');
    $tokens['subscription']['subscription-name'] = t('The subscription name.');
    $tokens['subscription']['subscription-description-short'] = t('The subscription short description.');
    $tokens['subscription']['subscription-description-long'] = t('The subscription long description.');
  }
  if ($type == 'event' || $type == 'all') {
    $tokens['event']['event-type-description'] = t('Description of event type.');
    $tokens['event']['event-date-small'] = t('Date of the event, short format.');
    $tokens['event']['event-date-medium'] = t('Date of the event, medium format.');
    $tokens['event']['event-date-large'] = t('Date of the event, large format.');
  }
  if ($type == 'destination' || $type == 'all') {
    // Nore destination tokens provided by messaging module
    $tokens['destination']['destination-unsubscribe-url'] = t('URL to unsubscribe to the destination.');
    $tokens['destination']['destination-manage-url'] = t('URL to manage all subscriptions for the destination.');
    $tokens['destination']['destination-edit-url'] = t('URL to edit the destination.');

  }
  return $tokens;
}

/**
 * Get event types. Invoking this function will also load the event API
 * 
 * @param $typekey
 *   Event type key
 * @param $property
 *   Property to return
 * @param $enabled
 *   Whether to return also disabled events
 */
function notifications_event_types($typekey = NULL, $property = NULL, $disabled = TRUE) {
  $info = &notifications_info('event types');
  $enabled = &drupal_static(__FUNCTION__ . '_enabled');
  if (!isset($enabled)) {
    $enabled = array();
    foreach ($info as $key => &$event) {
      if (empty($event['disabled']) && notifications_event_enabled($key)) {
        $enabled[$key] = &$event;
      }
    }
  }
  return $disabled ? messaging_array_info($info, $typekey, $property) : messaging_array_info($enabled, $typekey, $property);
}

/**
 * Information about digesting method for a send interval.
 * 
 * @return array()
 *   Ditest information for that interval, or all the information if no interval
 */
function notifications_build_method($send_interval = NULL, $refresh = FALSE) {
  $build_methods = notifications_info('build methods', NULL, $refresh);
  $intervals = variable_get('notifications_digest_methods', array());

  if (is_null($send_interval)) {
    return $build_methods;
  }
  elseif (!empty($intervals[$send_interval]) && isset($build_methods[$intervals[$send_interval]])) {
    return $build_methods[$intervals[$send_interval]];
  }
  else {
    // Default, that will be always the simple one
    return $build_methods['simple'];
  }
}

/**
 * Invoke hook_notifications($name) on all modules
 * 
 * This is like module_invoke all with some differences:
 * - The results are just merged (not recursively)
 * - The module name is added to each resulting array
 * - We cache all the results 
 */
function &notifications_info($name, $param = NULL, $refresh = FALSE) {
  $info = &drupal_static('notifications_info_' . $name);
  if (!isset($info) || $refresh) {
    $info = messaging_module_invoke_all('notifications', $name, $param);
    // Provide alter hook: notifications_name
    drupal_alter('notifications_' . strtr($name, ' ', '_'), $info);
  }      
  return $info;
}

/**
 * Entry point for the storage and queueing API
 * 
 * Default methods are implemented by Notifications_Queue class
 * 
 * This API can be replaced by setting a new class name in the 'notifications_queue' variable.
 */
function notifications_queue() {
  static $queue;
  if (!isset($queue)) {
    $class = variable_get('notifications_queue', 'Notifications_Queue');
    $queue = new $class();
  }
  //return call_user_func_array(array($class, $method), $args);
  return $queue;
}
<?php
// $Id: notifications_tags.module,v 1.1.2.5.2.12.2.5.2.8 2010/05/11 10:38:20 jareyero Exp $
/**
 * @file
 * Subscriptions to taxonomy terms
 */

/**
 * Implementation of hook_menu_()
 */
function notifications_tags_menu() {
  $items['admin/config/notifications/subscriptions/tags'] = array(
    'title' => 'Tags',
    'description' => 'Options for taxonomy subscriptions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_tags_admin_settings'),
    'access arguments' => array('administer notifications'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'notifications_tags.admin.inc',
  );
  $items['notifications_tags/autocomplete'] = array(
    'title' => 'Autocomplete taxonomy',
    'page callback' => 'notifications_tags_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  // Hidden user account tab, unless notifications_user enabled
  $items['user/%user/notifications/taxonomy'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Tags',     
    'access callback' => 'notifications_tags_user_access',
    'access arguments' => array(1, 'taxonomy_term'),
    'page callback' => 'notifications_user_subscription_list_page',
    'page arguments' => array('taxonomy_term', 1),
    'weight' => 10,
  );
  return $items;
}

/**
 * Check access to user account tab
 */
function notifications_tags_user_access($account, $type) {
  return module_exists('notifications_user') && notifications_user_tab_access($account, $type);
}
/**
 * Implementation of hook_permission()
 */
function notifications_tags_permission() {
  return array(
    'subscribe to taxonomy terms' =>  array(
      'title' => t('Subscribe to taxonomy terms'),
      'description' => t('Subscribe to content tagged with a given taxonomy term.'),
    ),
  );
}

/**
 * Implementation of hook_notifications().
 */
function notifications_tags_notifications($op) {
  switch ($op) {

    case 'subscription types':
      $types['taxonomy_term'] = array(
        'title' => t('Tags'),
        'description' => t('Subscribe to content tagged with a given taxonomy term.'),
        'class' => 'Notifications_Taxonomy_Term_Subscription',
        'access' => array('subscribe to taxonomy terms'),
      );
      return $types;

    case 'field types':
      // Information about available fields for subscriptions
      $fields['term:tid'] = array(
        'title' => t('Taxonomy term'),
        'class' => 'Notifications_Taxonomy_Term_Field',
      );
      return $fields;
    
    case 'object types':
      // Define object types used by subscriptions and events
      $types['taxonomy_term'] = array(
        'title' => t('Taxonomy term'),
        'class' => 'Notifications_Taxonomy_Term'
      );
      return $types;
 
  }
}

/**
 * Implementation of hook notifications_subscription()
 */
function notifications_tags_notifications_subscription($op, $subscription = NULL, $account = NULL) {
  switch ($op) {
    case 'page objects':
      // Return objects on current page to which we can subscribe
      $objects = array();
      if (arg(0) == 'taxonomy') {
        if (arg(1) == 'term' && is_numeric(arg(2)) && ($term = taxonomy_get_term(arg(2)))) {
          $objects[] = notifications_object('taxonomy_term', $term);
        }
      }
      return $objects;
      break;
  }  
}


/**
 * Implementation of hook_notifications_object_node()
 */
function notifications_tags_notifications_object_node($op, $node, $account = NULL) {
  switch ($op) {

    case 'conditions':
      // For a queue query, when not account, we must use our own function to retrieve terms
      $tids = notifications_tags_node_get_terms($node);
      if (!empty($tids)) {
        return array('tid' => $tids);
      }
      break;

    case 'subscriptions':
      // Get all available subscriptions to current node
      $options = array();
      if (!$account || user_access('subscribe to taxonomy terms', $account)) {
        $vocabs = notifications_tags_vocabularies();
        if (notifications_content_type_enabled($node->type, 'taxonomy') && !empty($node->taxonomy)) {
          foreach ($node->taxonomy as $tid => $term) {
            if (array_key_exists($term->vid, $vocabs)) {
              $options[] = array(
                'name' => t('Posts tagged with @name', array('@name' => $term->name)),
                'type' => 'taxonomy',
                'fields' => array('tid' => $term->tid),
                'module' => 'notifications', // The module that will handle these subscriptions
              );
            }
          }
        }
      }
      return $options;
  }
}

/**
 * Implementation of hook_notifications_object_term()
 */
function notifications_tags_notifications_object_term($op, $term, $account = NULL) {
  switch ($op) {
    case 'conditions':
      return array('tid' => $term->tid);
      break;
    case 'subscriptions':
      // Get all available subscriptions to current node
      $options = array();
      if (!$account || user_access('subscribe to taxonomy terms', $account)) {
        $vocabs = notifications_tags_vocabularies();

        if (notifications_content_type_enabled(NULL, 'taxonomy') && array_key_exists($term->vid, $vocabs)) {
          $options[] = array(
            'name' => t('Posts tagged with %name', array('%name' => $term->name)),
            'type' => 'taxonomy',
            'fields' => array('tid' => $term->tid),
          );
        }
      }
      return $options;
  }
}

/**
* Implementation of hook_taxonomy().
*/
function notifications_tags_taxonomy($op, $type, $array = NULL) {
  switch ($op) {
    case 'delete':
      switch ($type) {
        case 'term':
          // takes care of individual term deletion and vocab deletion because taxonomy iterates through all term delete hooks on the latter
          Notifications_Subscription::delete_multiple(array(), array('term:tid' => $array['tid']), FALSE);
          break;
      }
      break;
  }
}

/**
 * Fields information, translate term tid to name
 */
function notifications_tags_term_name($tid, $html = FALSE) {
  if ($term = taxonomy_get_term($tid)) {
    return $html ? l($term->name, "taxonomy/term/$tid") : check_plain($term->name);
  }
}

/**
 * Fields information, translate term name to tid
 */
function notifications_tags_term_tid($name, $field = NULL) {
  if ($vocabs = notifications_tags_vocabularies()) {
    // Add vids and name to args
    $args = array_keys($vocabs);
    $args[] = $name;
    $tid = db_result(db_query_range(db_rewrite_sql("SELECT t.tid FROM {term_data} t WHERE t.vid IN (" . db_placeholders($vocabs) . ") AND LOWER(t.name) = LOWER('%s')", 't', 'tid'), $args, 0, 1));
    if ($tid) {
      return $tid;
    }
    elseif ($field) {
      form_set_error($field, t('Term name not found.'));
    }
  }
}

/**
 * Get list of allowed vocabularies
 * 
 * @param $field
 *   Optional field to retrieve as array value.
 *   If empty the whole vocalubary object will be returned.
 */
function notifications_tags_vocabularies($field = NULL) {
  $vocabularies = &drupal_static(__FUNCTION__);
  if (!isset($vocabularies)) {
    $vocabularies = array();
    if ($allowed = variable_get('notifications_tags_vocabularies', array())) {
      $allvocab = taxonomy_get_vocabularies();
      foreach (array_filter($allowed) as $vid) {
        $vocabularies[$vid] = $allvocab[$vid];
      } 
    }
  }
  if ($field) {
    $list = array();
    foreach ($vocabularies as $vid => $vocab) {
      $list[$vid] = $vocab->$field;
    }
    return $list;
  }
  else {
    return $vocabularies;
  }
}

/**
 * Helper function to get latest node terms that belong to our vocabularies for subscriptions
 * 
 * We cannot use the one from taxonomy module because it has static caching and we'll be sending
 * notifications right after the node has been updated
 */
function notifications_tags_node_get_terms($node) {
  static $terms;

  if (!isset($terms[$node->nid])) {
    $terms[$node->nid] = array();
    if ($vocabularies = notifications_tags_vocabularies()) {
      // We just get terms for allowed vocabularies
      $vids = array_keys($vocabularies);
      $args = array_merge(array($node->nid), $vids);
      $result = db_query('SELECT t.tid FROM {term_node} t INNER JOIN {term_data} d ON t.tid = d.tid WHERE t.nid = %d AND d.vid IN(' . db_placeholders($vids) . ')', $args);      
      while ($term = db_fetch_object($result)) {
        $terms[$node->nid][] = $term->tid;
      }
    }
  }
  return $terms[$node->nid];
}

/**
 * Helper function for term name autocompletion
 * 
 * It is similar to taxonomy_autocomplete but:
 * - Just searches terms in allowed vocabularies
 * - Has single/multiple switch in the path
 * 
 * @param $type
 *   'single' or 'multiple'
 */
function notifications_tags_autocomplete($type, $string = '') {
  $matches = array();
  if ($vocabs = notifications_tags_vocabularies()) {
    // If multiple, the user enters a comma-separated list of tags. We only autocomplete the last tag.
    if ($type == 'multiple') {
      $array = drupal_explode_tags($string);
    } else {
      $array = array($string);
    }
    // Fetch last tag
    $last_string = trim(array_pop($array));

    if ($last_string != '') {
      // Add vids and name to args
      $args = array_keys($vocabs);
      $args[] = $last_string;
      $result = db_query_range(db_rewrite_sql("SELECT t.tid, t.name FROM {term_data} t WHERE t.vid IN (" . db_placeholders($vocabs) . ") AND LOWER(t.name) LIKE LOWER('%%%s%%')", 't', 'tid'), $args, 0, 10);
  
      $prefix = count($array) ? implode(', ', $array) .', ' : '';
  
      while ($tag = db_fetch_object($result)) {
        $n = $tag->name;
        // Commas and quotes in terms are special cases, so encode 'em.
        if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {
          $n = '"'. str_replace('"', '""', $tag->name) .'"';
        }
        $matches[$prefix . $n] = check_plain($tag->name);
      }
    }
  }
  drupal_json($matches);
}